<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Zhou Yuanda">


    <meta name="subtitle" content="试问谁可，洁白无比？">


    <meta name="description" content="当然我也在扯淡。。">


    <meta name="keywords" content="前端开发">


<title>Vue 全家桶学习总结 | Ada 的个人博客主页</title>



    <link rel="icon" href="/image/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 4.2.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Ada&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Ada&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Vue 全家桶学习总结</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Zhou Yuanda</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">February 26, 2019&nbsp;&nbsp;23:32:17</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="Vue-js-特性："><a href="#Vue-js-特性：" class="headerlink" title="Vue.js 特性："></a>Vue.js 特性：</h2><p>1.轻量级<br>2.双向数据绑定<br>3.指令<br>4.组件化</p>
<h2 id="什么是-MVVM"><a href="#什么是-MVVM" class="headerlink" title="什么是 MVVM"></a>什么是 MVVM</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MVC &#x3D;&gt; MVP &#x3D;&gt; MVVM</span><br><span class="line">&#x2F;&#x2F; 视图层和数据层的双向绑定</span><br><span class="line">View &lt;&#x3D;&gt; ViewModel &lt;&#x3D;&gt; Model</span><br></pre></td></tr></table></figure>
<ol>
<li><p>MVVM是一种设计思想， 是 Model-View-ViewModel 的缩写。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。</p>
</li>
<li><p>在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到Model 中，而 Model 数据的变化也会立即反应到 View 上。</p>
</li>
<li><p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p>
</li>
</ol>
<h2 id="Vue-js-的优点"><a href="#Vue-js-的优点" class="headerlink" title="Vue.js 的优点"></a>Vue.js 的优点</h2><ol>
<li>低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</li>
<li>可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</li>
<li>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</li>
<li>可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写</li>
<li>易用灵活高效</li>
</ol>
<h2 id="Vue-组件是什么"><a href="#Vue-组件是什么" class="headerlink" title="Vue 组件是什么"></a>Vue 组件是什么</h2><p>组件 (Component) 是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以表现为用 is 特性进行了扩展的原生 HTML 元素。所有的 Vue 组件同时也都是 Vue 的实例，所以可接受相同的选项对象 (除了一些根级特有的选项) 并提供相同的生命周期钩子。</p>
<h1 id="Vue-cli"><a href="#Vue-cli" class="headerlink" title="Vue-cli"></a>Vue-cli</h1><p>Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，致力于将 Vue 生态中的工具基础标准化。</p>
<h2 id="Vue-脚手架-3-x-以上版本使用"><a href="#Vue-脚手架-3-x-以上版本使用" class="headerlink" title="Vue 脚手架 3.x 以上版本使用"></a>Vue 脚手架 3.x 以上版本使用</h2><p>全局安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global add @vue&#x2F;cli</span><br></pre></td></tr></table></figure>
<p>快速原型开发</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue&#x2F;cli-service-global</span><br></pre></td></tr></table></figure>
<p>创建项目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vue create hello-world</span><br><span class="line">&#x2F;&#x2F; 如果是在 Windows 上通过 minTTY 使用 Git Bash，交互提示符并不工作，需要执行下面命令</span><br><span class="line">winpty vue.cmd create hello-world</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd hello-world</span><br></pre></td></tr></table></figure>
<p>Project setup</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn install</span><br></pre></td></tr></table></figure>
<p>（以下命令 run 可以省略）<br>Compiles and hot-reloads for development</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run serve</span><br></pre></td></tr></table></figure>
<p>Compiles and minifies for production</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run build</span><br></pre></td></tr></table></figure>
<p>Run your tests</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run test</span><br></pre></td></tr></table></figure>
<p>Lints and fixes files</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run lint</span><br></pre></td></tr></table></figure>
<h2 id="Vuecli-3-x-版本-上图-与-2-x-初始化目录对比"><a href="#Vuecli-3-x-版本-上图-与-2-x-初始化目录对比" class="headerlink" title="Vuecli 3.x 版本(上图)与 2.x 初始化目录对比"></a>Vuecli 3.x 版本(上图)与 2.x 初始化目录对比</h2><p><img src="https://upload-images.jianshu.io/upload_images/7094266-35ec0c0fd8c70b11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7094266-2e5b972e8f4586e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h1 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h1><p>Vue Router 是 Vue.js 官方的路由管理器。<br>安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router</span><br></pre></td></tr></table></figure>
<p>引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import VueRouter from &#39;vue-router&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br></pre></td></tr></table></figure>
<p>配置路由文件，并在vue实例中注入 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes:[&#123;</span><br><span class="line">    path:&#39;&#x2F;user&#x2F;:userId&#39;, &#x2F;&#x2F; 指定要跳转的路径</span><br><span class="line">    name: &#39;user&#39;, &#x2F;&#x2F; 命名路由，便于路由跳转</span><br><span class="line">    component: User&#x2F;&#x2F; 指定要跳转的组件</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br><span class="line">const User &#x3D; (&#123;</span><br><span class="line">  template: &#39;&lt;div&gt;User&lt;&#x2F;div&gt;&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="确定视图加载的位置"><a href="#确定视图加载的位置" class="headerlink" title="确定视图加载的位置"></a>确定视图加载的位置</h2><p>视图可以添加命名，如果 router-view 没有设置名字，那么默认为 default</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">&lt;router-view name&#x3D;&quot;a&quot;&gt;&lt;&#x2F;router-view&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;&#39;,</span><br><span class="line">      components: &#123; &#x2F;&#x2F; 同个路由，多个视图就需要多个组件,components 要有(s)</span><br><span class="line">        default: Foo,</span><br><span class="line">        a: Bar</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="实现路由跳转"><a href="#实现路由跳转" class="headerlink" title="实现路由跳转"></a>实现路由跳转</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to&#x3D;&quot;&#123; name: &#39;user&#39;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;&#x2F;router-link&gt; &#x2F;&#x2F; 路由导航到 &#x2F;user&#x2F;123</span><br></pre></td></tr></table></figure>
<p>等同于代码调用 router.push() </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 编程式导航</span><br><span class="line">router.push(&#123; name: &#39;user&#39;, params: &#123; userId: 123 &#125;&#125;) &#x2F;&#x2F; 路由导航到 &#x2F;user&#x2F;123</span><br></pre></td></tr></table></figure>
<h2 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h2><p>使用动态路由参数，以冒号开头</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const User &#x3D; &#123;</span><br><span class="line">  template: &#39;&lt;div&gt;User&lt;&#x2F;div&gt;&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#x2F;&#x2F; 动态路径参数 以冒号开头</span><br><span class="line">    &#123; path: &#39;&#x2F;user&#x2F;:id&#39;, component: User &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>现在呢，像 /user/foo 和 /user/bar 都将映射到相同的路由。</p>
<p>当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const User &#x3D; &#123;</span><br><span class="line">  template: &#39;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;&#x2F;div&gt;&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="响应路由参数变化"><a href="#响应路由参数变化" class="headerlink" title="响应路由参数变化"></a>响应路由参数变化</h2><p>动态路由会引起组件复用，如果想对路由参数的变化作出响应，可以简单地 <strong>watch</strong> (监测变化) $route 对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const User &#x3D; &#123;</span><br><span class="line">  template: &#39;...&#39;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    &#39;$route&#39; (to, from) &#123;</span><br><span class="line">      &#x2F;&#x2F; 对路由变化作出响应...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者使用 <strong>beforeRouteUpdate</strong> 导航守卫</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const User &#x3D; &#123;</span><br><span class="line">  template: &#39;...&#39;,</span><br><span class="line">  beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">    &#x2F;&#x2F; react to route changes...</span><br><span class="line">    &#x2F;&#x2F; don&#39;t forget to call next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="路由组件参数解耦"><a href="#路由组件参数解耦" class="headerlink" title="路由组件参数解耦"></a>路由组件参数解耦</h2><p>在组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。可使用 props 解耦组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const User &#x3D; &#123;</span><br><span class="line">  props: [&#39;id&#39;],</span><br><span class="line">  template: &#39;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;&#x2F;div&gt;&#39;</span><br><span class="line">&#125;</span><br><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &#39;&#x2F;user&#x2F;:id&#39;, component: User, props: true &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 对于包含命名视图的路由，你必须分别为每个命名视图添加 &#96;props&#96; 选项：</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;user&#x2F;:id&#39;,</span><br><span class="line">      components: &#123; default: User, sidebar: Sidebar &#125;,</span><br><span class="line">      props: &#123; default: true, sidebar: false &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>props 有三种模式：布尔模式、对象模式、函数模式</p>
<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><p>Vuex 是一个为 Vue.js 开发的状态管理模式：采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
<h2 id="在-store-存储-内有下列核心概念"><a href="#在-store-存储-内有下列核心概念" class="headerlink" title="在 store (存储)内有下列核心概念"></a>在 store (存储)内有下列核心概念</h2><p><strong>State()：核心原始数据</strong> 展示<br><strong>Getter：计算属性，根据所依赖的数据的变化计算自身变化</strong> 存储<br><strong>Mutation(转变)：提交 mutation 才能改变存储状态</strong><br><strong>Action：</strong>Action 类似于 mutation，不同在于：<br>Action 提交的是 mutation，而不是直接变更状态。<br>Action 可以包含任意异步操作。<br><strong>Module：可以将将 store 分割</strong><br>一般放在 state 文件夹下</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7094266-c1e2d56805eff7e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="vuex状态管理的流程"><a href="#vuex状态管理的流程" class="headerlink" title="vuex状态管理的流程"></a>vuex状态管理的流程</h2><p>view =&gt; actions =&gt; mutations =&gt; state =&gt; view</p>
<h2 id="核心概念详解"><a href="#核心概念详解" class="headerlink" title="核心概念详解"></a>核心概念详解</h2><h3 id="state：记录所有公共数据状态的对象"><a href="#state：记录所有公共数据状态的对象" class="headerlink" title="state：记录所有公共数据状态的对象"></a>state：记录所有公共数据状态的对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 组件如何获取</span><br><span class="line">this.$store.state.XXX</span><br><span class="line">&#x2F;&#x2F; 此处的 XXX 是 state 内定义的数据状态的键名</span><br></pre></td></tr></table></figure>
<h3 id="mutations：包含所有-操作数据状态的方法-的对象"><a href="#mutations：包含所有-操作数据状态的方法-的对象" class="headerlink" title="mutations：包含所有 操作数据状态的方法 的对象"></a>mutations：包含所有 操作数据状态的方法 的对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 组件如何调用</span><br><span class="line">this.$store.commit(XXX)</span><br><span class="line">&#x2F;&#x2F; 此处的 XXX是 mutations 中定义的方法名</span><br></pre></td></tr></table></figure>
<h3 id="actions：用于操作-mutations-内方法-的对象"><a href="#actions：用于操作-mutations-内方法-的对象" class="headerlink" title="actions：用于操作 mutations 内方法 的对象"></a>actions：用于操作 mutations 内方法 的对象</h3><p>actions 提交的是 mutation，而不是直接变更状态 actions可以包含异步操作，但是 mutation 只能包含同步操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如何调用</span><br><span class="line">this.$store.dispatch(XXX)</span><br><span class="line">&#x2F;&#x2F; 此处的XXX是你在actions中定义的方法名</span><br></pre></td></tr></table></figure>
<h3 id="getters：定义状态内容的方法-的对象"><a href="#getters：定义状态内容的方法-的对象" class="headerlink" title="getters：定义状态内容的方法 的对象"></a>getters：定义状态内容的方法 的对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.$store.getters.XXX</span><br><span class="line">&#x2F;&#x2F; 此处的XXX是你在getters里定义的方法名</span><br></pre></td></tr></table></figure>
<h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>当应用较大时，store将变得臃肿，Vuex 允许我们将 store 分割成模块（module）。<br>每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const moduleA &#x3D; &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const moduleB &#x3D; &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a &#x2F;&#x2F; -&gt; moduleA 的状态</span><br><span class="line">store.state.b &#x2F;&#x2F; -&gt; moduleB 的状态</span><br></pre></td></tr></table></figure>
<h1 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h1><p>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征：</p>
<ul>
<li>从浏览器中创建 XMLHttpRequest</li>
<li>从 node.js 发出 http 请求</li>
<li>支持 Promise API拦截</li>
<li>请求和响应转换</li>
<li>请求和响应数据取消</li>
<li>请求自动转换JSON数据</li>
<li>客户端支持防止 CSRF/XSRF</li>
</ul>
<ol>
<li>安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure></li>
<li>引入加载<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import axios from &#39;axios&#39;</span><br></pre></td></tr></table></figure></li>
<li>将axios全局挂载到 Vue 原型上<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$http &#x3D; axios</span><br></pre></td></tr></table></figure>
<h2 id="设置全局-axios-默认值"><a href="#设置全局-axios-默认值" class="headerlink" title="设置全局 axios 默认值"></a>设置全局 axios 默认值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 设置基础路径，一般为后端接口线上地址根路径</span><br><span class="line">axios.defaults.baseURL &#x3D; &#39;https:&#x2F;&#x2F;api.example.com&#39;;</span><br><span class="line">&#x2F;&#x2F; 设置默认 token</span><br><span class="line">axios.defaults.headers.common[&#39;Authorization&#39;] &#x3D; AUTH_TOKEN;</span><br><span class="line">&#x2F;&#x2F; 默认 POST 请求</span><br><span class="line">axios.defaults.headers.post[&#39;Content-Type&#39;] &#x3D; &#39;application&#x2F;x-www-form-urlencoded&#39;;</span><br></pre></td></tr></table></figure>
<h2 id="axios-的-url-有两种传递参数的形式"><a href="#axios-的-url-有两种传递参数的形式" class="headerlink" title="axios 的 url 有两种传递参数的形式"></a>axios 的 url 有两种传递参数的形式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一种 对象形式</span><br><span class="line">this.$http.get(&#39;&#x2F;user&#39;, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      ID: 12345</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#x2F;&#x2F; 如果只有一个参数，可以省略 params</span><br><span class="line">this.$http.get(&#39;&#x2F;user&#39;, &#123;</span><br><span class="line">      ID: 12345</span><br><span class="line">  &#125;) </span><br><span class="line">--------------------------------- </span><br><span class="line">&#x2F;&#x2F; 第二种 形式</span><br><span class="line">this.$http.get(&#39;https:&#x2F;&#x2F;cnodejs.org&#x2F;api&#x2F;v1&#x2F;topics?page&#x3D;1&amp;limit&#x3D;15&#39;)</span><br></pre></td></tr></table></figure>
<h2 id="POST-传递数据有两种格式："><a href="#POST-传递数据有两种格式：" class="headerlink" title="POST 传递数据有两种格式："></a>POST 传递数据有两种格式：</h2></li>
<li>form­-data ?page=1&amp;limit=48</li>
<li>x-­www­-form-­urlencoded { page: 1,limit: 10 }</li>
</ol>
<p><strong>在 axios 中，post 请求接收的参数必须是 form­-data 形式<br>如果要使用 x-­www­-form-­urlencoded 形式，需要用 qs 插件—qs.stringify 转换</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.$http.post(&#39;&#x2F;user&#39;, qs.stringify(&#123;</span><br><span class="line">   ID: 12345</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="实现增删改查"><a href="#实现增删改查" class="headerlink" title="实现增删改查"></a>实现增删改查</h2><h3 id="发起-GET-请求：查"><a href="#发起-GET-请求：查" class="headerlink" title="发起 GET 请求：查"></a>发起 GET 请求：查</h3><p><img src="https://upload-images.jianshu.io/upload_images/7094266-12145e74b1272089.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const axios &#x3D; require(&#39;axios&#39;) &#x2F;&#x2F; 下同省略</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;发起一个user请求，参数为给定的ID</span><br><span class="line">axios.get(&#39;&#x2F;user?ID&#x3D;12345&#39;)</span><br><span class="line">  .then((response) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(response)</span><br><span class="line">  &#125;</span><br><span class="line">  .catch((error) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(error)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="发起-POST-请求：增"><a href="#发起-POST-请求：增" class="headerlink" title="发起 POST 请求：增"></a>发起 POST 请求：增</h3><p><img src="https://upload-images.jianshu.io/upload_images/7094266-8609f819ec24a9ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.post(&#39;&#x2F;user&#39;, &#123;</span><br><span class="line">  firstName: &#39;yuanda&#39;,</span><br><span class="line">  lastName: &#39;zhou&#39;</span><br><span class="line">&#125;)</span><br><span class="line">  .then((response) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(response)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function(error)&#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.request(config)</span><br><span class="line">axios.get(url[,config])</span><br><span class="line">axios.delete(url[,config]) &#x2F;&#x2F; 删除</span><br><span class="line">axios.head(url[,config])</span><br><span class="line">axios.options(url[,config])</span><br><span class="line">axios.post(url[,data[,config]])</span><br><span class="line">axios.put(url[,data[,config]]) &#x2F;&#x2F; 改</span><br><span class="line">axios.patch(url[,data[,config]])</span><br></pre></td></tr></table></figure>
<p>PUT 和 POST 方法的区别是,PUT方法是幂等的：连续调用一次或者多次的效果相同（无副作用）。连续调用同一个POST可能会带来额外的影响，比如多次提交订单。</p>
<h2 id="并发请求"><a href="#并发请求" class="headerlink" title="并发请求"></a>并发请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function getUserAccount()&#123;</span><br><span class="line">    return axios.get(&#39;&#x2F;user&#x2F;12345&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getUserPermissions()&#123;</span><br><span class="line">    return axios.get(&#39;&#x2F;user&#x2F;12345&#x2F;permissions&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios.all([getUerAccount(),getUserPermissions()])</span><br><span class="line">    .then(axios.spread(function(acc,pers)&#123;</span><br><span class="line">        &#x2F;&#x2F;两个请求现在都完成</span><br><span class="line">    &#125;));</span><br></pre></td></tr></table></figure>
<p>axios.all 使用的是类似 Primise.all 的功能，所以如果其中有一个请求出现了错误那么就会停止请求，所以建议对于单个请求最好附加上处理的 catch。</p>
<h2 id="拦截器-interceptors"><a href="#拦截器-interceptors" class="headerlink" title="拦截器 interceptors"></a>拦截器 interceptors</h2><p>你可以在<strong>请求</strong>或者<strong>响应</strong>被 then 或者 catch 处理之前对他们进行拦截。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;添加一个请求拦截器</span><br><span class="line">axios.interceptors.request.use(function(config)&#123;</span><br><span class="line">    &#x2F;&#x2F;在请求发送之前做一些事</span><br><span class="line">    return config;</span><br><span class="line">&#125;,function(error)&#123;</span><br><span class="line">    &#x2F;&#x2F;当出现请求错误是做一些事</span><br><span class="line">    return Promise.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;添加一个返回拦截器</span><br><span class="line">axios.interceptors.response.use(function(response)&#123;</span><br><span class="line">    &#x2F;&#x2F;对返回的数据进行一些处理</span><br><span class="line">    return response;</span><br><span class="line">&#125;,function(error)&#123;</span><br><span class="line">    &#x2F;&#x2F;对返回的错误进行一些处理</span><br><span class="line">    return Promise.reject(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>用 eject 移除拦截器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myInterceptor &#x3D; axios.interceptors.request.use(function()&#123;&#x2F;*...*&#x2F;&#125;);</span><br><span class="line">axios.interceptors.request.eject(myInterceptor);</span><br></pre></td></tr></table></figure>
<h2 id="axios-如何获取-cookie"><a href="#axios-如何获取-cookie" class="headerlink" title="axios 如何获取 cookie"></a>axios 如何获取 cookie</h2><p>axios 默认是不让 ajax 请求头部携带cookie的，因此，在 main.js 中设置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import axios from &#39;axios&#39;</span><br><span class="line">axios.defaults.withCredentials&#x3D;true; &#x2F;&#x2F;让ajax携带cookie</span><br><span class="line">Vue.prototype.$axios &#x3D; axios;</span><br></pre></td></tr></table></figure>
<p>通过js原生接口来获取: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let allCookies &#x3D; document.cookie</span><br></pre></td></tr></table></figure>
        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Zhou Yuanda</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://github.com/Adashuai5/Adashuai5.github.io/2019/02/26/Vue-%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">https://github.com/Adashuai5/Adashuai5.github.io/2019/02/26/Vue-%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Vue/"># Vue</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2019/03/28/LeetCode-%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/">LeetCode 算法之旅</a>
            
            
            <a class="next" rel="next" href="/2018/12/29/%E4%BB%8E%E3%80%8C%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E3%80%8D%E8%B0%88%E5%8F%8AWeb%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">从「从输入 URL 到页面加载」谈及Web性能优化</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Zhou Yuanda | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
